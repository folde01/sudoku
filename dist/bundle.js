/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Game = __webpack_require__(/*! ./game */ \"./src/js/game.js\");\nconst Board = __webpack_require__(/*! ./board */ \"./src/js/board.js\");\n\nconst log = console.log;\nconst board = new Board();\nlet game;\n\nwindow.addEventListener('click', function(event) {\n    if (!event.target.classList.contains('newGame') && !event.target.classList.contains('gameOver')) {\n        return;\n    }\n    \n    game = new Game(board);\n    game.play();\n});\n\ngame = new Game(board);\ngame.play();\n\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ }),

/***/ "./src/js/board.js":
/*!*************************!*\
  !*** ./src/js/board.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const log = console.log;\nconst CONSTANTS = __webpack_require__(/*! ./constants */ \"./src/js/constants.js\");\n\n/**\n * @classdesc Board takes care of all DOM interaction, including drawing the empty board, populating it with values before play, and controlling the user interface during play.\n */\nclass Board {\n    constructor() {\n        this._boardSize = CONSTANTS.boardSize;\n        this._domCache = {\n            logo: document.querySelector('#logo'),\n            board: document.querySelector('#board'),\n            inputTable: document.querySelector('.inputTable'),\n            inputCells: document.querySelectorAll('.inputCell'),\n            newGameButton: document.querySelector('.newGame'),\n            rows: document.querySelectorAll('.row'),\n            gameOver: document.querySelector('.gameOver'),\n            overlay: document.querySelector('.overlay')\n        };\n        this._domCache.cellsXY = this._draw();\n        this._domCache.cells = document.querySelectorAll('.cell');\n        this._conflictingCellIndex = { 'index': null };\n        this._boxInfo = CONSTANTS.boxInfo;\n        this._activeCellIndex = null;\n    }\n\n\n    // Public methods\n\n\n    getConflictingCellIndex() {\n        const index = this._conflictingCellIndex['index'];\n        return index;\n    }\n\n    setConflictingCellIndex(index) {\n        this._conflictingCellIndex['index'] = index;\n    }\n\n\n    addConflictHighlighting(cellX, cellY) {\n        try {\n            const domCell = this._getDomCell(cellX, cellY);\n            domCell.classList.add('invalidMove');\n            const index = this.getCellIndexFromCoords(cellX, cellY);\n            this.setConflictingCellIndex(index);\n        } catch (e) {\n            throw \"addConflictHighlighting caught exception: \" + e;\n        }\n    }\n\n    removeConflictHighlighting(cellX, cellY) {\n        try {\n            const domCell = this._getDomCell(cellX, cellY);\n            domCell.classList.remove('invalidMove');\n            this.setConflictingCellIndex(null);\n        } catch (e) {\n            throw \"removeConflictHighlighting caught exception: \" + e;\n        }\n    }\n\n    getCellIndexFromCoords(cellX, cellY) {\n        const index = (this._boardSize * cellY) + cellX;\n        return index;\n    }\n\n    populate(cellDB) {\n        this._clearBoard();\n\n        // Cache board cells from DOM\n        const cells = this._domCache.cells;\n        const rows = this._domCache.rows;\n        const board = this;\n        const boardSize = this._boardSize;\n\n        // Populate cells and cell DB (for checking move validity) arrays with values from cellValues. \n        cells.forEach(function (cell, cellIndex) {\n            const cellX = this.getCellX(cellIndex);\n            const cellY = this.getCellY(cellIndex);\n\n            const cellValue = cellDB.getCellValue(cellX, cellY);\n            let cellValueToRender = null;\n\n            if (cellValue === 0) {\n                // It's an empty cell.\n                cellValueToRender = '';\n            } else {\n                // It's a clue cell.\n                cellValueToRender = cellValue.toString();\n                cell.classList.add('clueCell');\n            }\n            cell.innerText = cellValueToRender;\n        }.bind(this));\n    }\n\n    getCellX(cellIndex) {\n        return cellIndex % this._boardSize;\n    }\n\n    getCellY(cellIndex) {\n        return Math.floor(cellIndex / this._boardSize);\n    }\n\n    play(game) {\n\n        this._game = game;\n        const cells = this._domCache.cells;\n        const inputCells = this._domCache.inputCells;\n        const inputTable = this._domCache.inputTable;\n        \n        // Helps ensure only one cell is ever active (selected) at a time\n        // let activeCellIndex = null;\n        let activeCellIndex = this._activeCellIndex;\n\n        const board = this;\n\n        // Adds event listeners to all cells except clue cells.\n        cells.forEach(function (cell, cellIndex) {\n            // Non-clue cells\n            const cellX = board.getCellX(cellIndex);\n            const cellY = board.getCellY(cellIndex);\n\n            if (game.cellDB.getCellValue(cellX, cellY) === 0) {\n\n                cell.onclick = function () {\n\n                    // Removes any conflict highlighting from last move\n                    game.removeAllConflicts();\n\n                    // Deactivates active cell if there is one, then activates selected cell. \n                    if (activeCellIndex !== null) {\n                        cells[activeCellIndex].classList.remove('activeCell');\n                    }\n\n                    // Activates cell\n                    activeCellIndex = cellIndex;\n                    cells[activeCellIndex].classList.add('activeCell');\n\n                    // todo: Activates keyboard\n\n                    // Activates keypad.\n                    inputTable.classList.add('inputTableActive');\n                    inputCells.forEach(function (inputCell, inputCellIndex) {\n\n                        let renderedCellValue = inputCell.innerText;\n                        let numericCellValue;\n\n                        if (isNaN(renderedCellValue)) {\n                            // 0 is the code for an erased number\n                            numericCellValue = 0;\n                            renderedCellValue = '';\n                        } else {\n                            numericCellValue = Number(renderedCellValue);\n                        }\n\n                        // Uses onClick instead of addEventListener (as we need to replace a handler, not add one)\n                        inputCell.onclick = function () {\n\n                            game.playInCell(cellX, cellY, numericCellValue);\n\n                            game.highlightIfConflicting(cellX, cellY, numericCellValue);\n\n                            // Sets cell value in DOM.\n                            cell.innerText = renderedCellValue;\n\n                            // Deactivates cell \n                            cell.classList.remove('activeCell');\n\n                            this._setBackButtonHighlighting();\n\n                            this._deactivateKeypads();\n\n                            if (game.userHasSolvedPuzzle()) {\n                                this._doGameOver();\n                            }\n                        }.bind(board);\n                    });\n                };\n            }\n        });\n    }\n\n\n    // Private methods\n\n    _backButtonShouldBeHighlighted() {\n        if (!this._game) {\n            return false;\n        }\n\n        const res = this._game.getCellDB().getFilledCellCount() > 0;\n        // console.log('back', res);\n        return res;\n    }\n\n    _setBackButtonHighlighting() {\n        if (this._backButtonShouldBeHighlighted()) {\n            this._domCache.backButton.classList.add('backButtonHighlighted');\n        } else {\n            this._domCache.backButton.classList.remove('backButtonHighlighted');\n        }\n    }\n\n\n    _clearBoard() {\n        this._hideGameOver();\n        this._deactivateKeypads();\n        this._clearCells();\n        this._addCheckerBoard();\n    }\n\n    _hideGameOver() {\n        // const gameOver = this.domCache.gameOver;\n        const overlay = this._domCache.overlay;\n        // gameOver.innerText = '';\n        overlay.style.display = 'none';\n\n    }\n\n    _deactivateKeypads() {\n        this._domCache.inputTable.classList.remove('inputTableActive');\n        this._domCache.inputCells.forEach(function (inputCell, inputCellIndex) {\n            inputCell.onclick = null;\n            // inputCell.onclick = function () { return false; };\n        });\n    }\n\n    _clearCells() {\n        this._domCache.cells.forEach(function (cell) {\n            cell.classList.remove('clueCell');\n            cell.classList.remove('activeCell');\n            cell.classList.remove('invalidMove');\n            cell.onclick = null;\n        });\n    }\n\n\n\n    _getDomCell(cellX, cellY) {\n        // Todo: cache these\n        const boardSize = this._boardSize;\n        const selector = '#cell' + cellX + cellY;\n        if (isNaN(cellX) || isNaN(cellY) || cellX > boardSize - 1 || cellX < 0 || cellY > boardSize - 1 || cellY < 0) {\n            throw \"getDomCell: unexpected cell coordinate. (cellX, cellY): \" + cellX + ', ' + cellY;\n        }\n\n        return this._domCache.cellsXY[selector];\n    }\n\n    _addCheckerBoard() {\n        const checkerboardBoxes = ['n', 's', 'e', 'w'];\n\n        checkerboardBoxes.forEach(function (box, index) {\n            const boxInfo = this._boxInfo[box];\n\n            for (let cellX = boxInfo.startCellX; cellX <= boxInfo.endCellX; cellX++) {\n                for (let cellY = boxInfo.startCellY; cellY <= boxInfo.endCellY; cellY++) {\n                    this._getDomCell(cellX, cellY).classList.add('checkerboardBoxCell');\n                }\n            }\n        }.bind(this));\n    }\n\n    _doGameOver() {\n        const overlay = this._domCache.overlay;\n        overlay.style.display = 'block';\n    }\n\n    _draw() {\n        const domCache = this._domCache;\n        const boardSize = this._boardSize;\n        const cellsXY = {};\n\n        // logo\n        const logo = document.createElement('ul');\n        logo.setAttribute('id', 'logo');\n        const logoChars = ('  SUDOKU ').split('');\n\n        for (let i = 0; i < 9; i++) {\n            const li = document.createElement('li');\n            li.innerText = logoChars[i];\n            logo.appendChild(li);\n        }\n\n        // new game button\n        const li = document.createElement('li');\n        li.innerText = 'New game';\n        li.setAttribute('class', 'newGame');\n        logo.appendChild(li);\n        const oldLogo = domCache.logo;\n        oldLogo.parentNode.replaceChild(logo, oldLogo);\n\n        // back button\n        const backButton = document.createElement('li');\n        backButton.innerText = '←';\n        backButton.setAttribute('class', 'backBtn');\n        const liToReplace = document.querySelector('#logo li');\n        liToReplace.parentNode.replaceChild(backButton, liToReplace);\n        domCache.backButton = backButton;\n\n        // board\n        const oldBoard = domCache.board;\n        const board = document.createElement('table');\n        board.setAttribute('id', 'board');\n\n        for (let i = 0; i < boardSize; i++) {\n            const rowNode = document.createElement('tr');\n            rowNode.setAttribute('class', 'row');\n            board.appendChild(rowNode);\n\n            for (let j = 0; j < boardSize; j++) {\n                const cellNode = document.createElement('td');\n                cellNode.setAttribute('class', 'cell');\n                const cellID = 'cell' + j + i;\n                cellNode.setAttribute('id', cellID);\n                cellsXY['#' + cellID] = cellNode;\n                rowNode.appendChild(cellNode);\n            }\n        }\n\n        oldBoard.parentNode.replaceChild(board, oldBoard);\n\n        // keypad\n        const inputTable = document.createElement('ul');\n        inputTable.setAttribute('class', 'inputTable');\n\n        for (let i = 0; i < boardSize; i++) {\n            const li = document.createElement('li');\n            li.innerText = (i + 1).toString();\n            li.setAttribute('class', 'inputCell');\n            inputTable.appendChild(li);\n        }\n\n        const eraseBtn = document.createElement('li');\n        eraseBtn.setAttribute('id', 'eraseBtn');\n        eraseBtn.setAttribute('class', 'inputCell');\n        // eraseBtn.innerText = 'Clear';\n        eraseBtn.innerText = 'Erase';\n        inputTable.appendChild(eraseBtn);\n\n        const oldInputTable = domCache.inputTable;\n        oldInputTable.parentNode.replaceChild(inputTable, oldInputTable);\n        domCache.inputCells = document.querySelectorAll('.inputCell');\n        domCache.inputTable = inputTable;\n\n        return cellsXY;\n    }\n}\n\nmodule.exports = Board;\n\n//# sourceURL=webpack:///./src/js/board.js?");

/***/ }),

/***/ "./src/js/cellDB.js":
/*!**************************!*\
  !*** ./src/js/cellDB.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CONSTANTS = __webpack_require__(/*! ./constants */ \"./src/js/constants.js\");\n\n/**\n * @classdesc The CellDB stores the game state, including the value placed in each cell (either as a clue or by the user) and whether cell's value puts it in conflict with another cell.\n */\nclass CellDB {\n    constructor() {\n        this._boardSize = 9;\n        this._cellDB = this._initialize();\n        this._boxInfo = CONSTANTS.boxInfo;\n        this._cellValueCounts = new Array(this._boardSize + 1).fill(0);\n        this._countCompleteCellValues = 0;\n        this._filledCellCount = 0;\n    }\n\n\n    // Public methods\n\n    getFilledCellCount() {\n        return this._filledCellCount;\n    }\n\n    setCellValue(cellX, cellY, cellValue) {\n        const oldCellValue = this.getCellValue(cellX, cellY);\n        this._cellDB[cellY][cellX].cellValue = cellValue;\n\n        if (oldCellValue === 0 && cellValue > 0) {\n            this._filledCellCount++;\n        } else if (oldCellValue > 0 && cellValue === 0) {\n            this._filledCellCount--;\n        }\n    }\n\n    getCellValue(cellX, cellY) {\n        return this._cellDB[cellY][cellX].cellValue;\n    }\n\n    getRowValues(cellY) {\n        return this._cellDB[cellY].map((cell) => cell.cellValue);\n    }\n\n    getColumnValues(cellX) {\n        let cellValues = [];\n\n        for (let cellY = 0; cellY < this._boardSize; cellY++) {\n            cellValues.push(this._cellDB[cellY][cellX].cellValue);\n        }\n\n        return cellValues;\n    }\n\n    getBoxValues(box) {\n        let cellValues = [];\n\n        const boxInfo = this._boxInfo[box];\n\n        for (let cellX = boxInfo.startCellX; cellX <= boxInfo.endCellX; cellX++) {\n            for (let cellY = boxInfo.startCellY; cellY <= boxInfo.endCellY; cellY++) {\n                cellValues.push(this.getCellValue(cellX, cellY));\n            }\n        }\n\n        return cellValues;\n    }\n\n    setCellClueStatus(cellX, cellY, isClue) {\n        this._cellDB[cellY][cellX].isClue = isClue;\n    }\n\n    getCellClueStatus(cellX, cellY) {\n        return this._cellDB[cellY][cellX].isClue;\n    }\n\n    cellIsEmpty(cellX, cellY) {\n        if (this.getCellValue(cellX, cellY) === 0) {\n            return true;\n        }\n        return false;\n    }\n\n    getConflictStatus(cellX, cellY) {\n        return this._cellDB[cellY][cellX].conflicting;\n    }\n\n    setConflictStatus(cellX, cellY, status) {\n        this._cellDB[cellY][cellX].conflicting = status;\n    }\n\n    getBoxInfo() {\n        return this._boxInfo;\n    }\n\n    getCellValueCount(cellValue) {\n        return this._cellValueCounts[cellValue];\n    }\n\n    incrementCellValueCount(cellValue) {\n        this._cellValueCounts[cellValue]++;\n\n        if (this._cellValueCounts[cellValue] === this._boardSize) {\n            this._countCompleteCellValues++;\n        }\n    }\n\n    decrementCellValueCount(cellValue) {\n        if (this._cellValueCounts[cellValue] === this._boardSize) {\n            this._countCompleteCellValues--;\n        }\n\n        this._cellValueCounts[cellValue]--;\n    }\n\n    getCompleteCellValueCount() {\n        return this._countCompleteCellValues;\n    }\n\n\n    rowIsValid(move) {\n        for (let cellX = 0; cellX < this._boardSize; cellX++) {\n            if (cellX !== move.getCellX() && (!this.cellIsEmpty(cellX, move.getCellY())) && this.getCellValue(cellX, move.getCellY()) === move.getCellValue()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boxIsValid(move) {\n        let result = true;\n\n        // todo: these start/end values should be calculated once at the beginning at then just accessed.\n        const startRow = Math.floor(move.getCellY() / 3) * 3;\n        const endRow = startRow + 2;\n        const startColumn = Math.floor(move.getCellX() / 3) * 3;\n        const endColumn = startColumn + 2;\n\n        for (let j = startRow; j <= endRow; j++) {\n            for (let i = startColumn; i <= endColumn; i++) {\n                if (this.getCellValue(i, j) !== 0 && this.getCellValue(i, j) === move.cellValue) {\n                    result = false;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    columnIsValid(move) {\n        // todo: return if false\n        let result = true;\n\n        for (let j = 0; j < this._boardSize; j++) {\n            if (this.getCellValue(move.getCellX(), j) !== 0 && this.getCellValue(move.getCellX(), j) === move.getCellValue()) {\n                result = false;\n            }\n        }\n\n        return result;\n    }\n\n\n    // Private methods\n\n    \n    _initialize() {\n        const boardSize = this._boardSize;\n        let cellDB = new Array(boardSize);\n\n        for (let i = 0; i < boardSize; i++) {\n            cellDB[i] = new Array(boardSize);\n\n            for (let j = 0; j < boardSize; j++) {\n                cellDB[i][j] = {\n                    cellValue: 0,\n                    conflicting: false,\n                    isClue: true,\n                    solutionValue: null,\n                    eventListener: { event: null, fn: null }\n                };\n            }\n\n        }\n        return cellDB;\n    }\n}\n\nmodule.exports = CellDB;\n\n//# sourceURL=webpack:///./src/js/cellDB.js?");

/***/ }),

/***/ "./src/js/constants.js":
/*!*****************************!*\
  !*** ./src/js/constants.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const CONSTANTS = {\n  boardSize: 9,\n  boxInfo: {\n    'nw': { startCellX: 0, endCellX: 2, startCellY: 0, endCellY: 2, counterpart: 'se' },\n    'n': { startCellX: 3, endCellX: 5, startCellY: 0, endCellY: 2, counterpart: 's' },\n    'ne': { startCellX: 6, endCellX: 8, startCellY: 0, endCellY: 2, counterpart: 'sw' },\n    'w': { startCellX: 0, endCellX: 2, startCellY: 3, endCellY: 5, counterpart: 'e' },\n    'c': { startCellX: 3, endCellX: 5, startCellY: 3, endCellY: 5, counterpart: 'c' },\n    'e': { startCellX: 6, endCellX: 8, startCellY: 3, endCellY: 5, counterpart: 'w' },\n    'sw': { startCellX: 0, endCellX: 2, startCellY: 6, endCellY: 8, counterpart: 'ne' },\n    's': { startCellX: 3, endCellX: 5, startCellY: 6, endCellY: 8, counterpart: 'n' },\n    'se': { startCellX: 6, endCellX: 8, startCellY: 6, endCellY: 8, counterpart: 'nw' }\n  }\n};\n\nmodule.exports = CONSTANTS;\n\n//# sourceURL=webpack:///./src/js/constants.js?");

/***/ }),

/***/ "./src/js/game.js":
/*!************************!*\
  !*** ./src/js/game.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CellDB = __webpack_require__(/*! ./cellDB */ \"./src/js/cellDB.js\");\nconst Puzzle = __webpack_require__(/*! ./puzzle */ \"./src/js/puzzle.js\");\nconst CONSTANTS = __webpack_require__(/*! ./constants */ \"./src/js/constants.js\");\nconst log = console.log;\n\n/**\n * @classdesc Game orchestrates the other classes in order to generate a puzzle, draw and populate the board and run the main game loop.\n */\nclass Game {\n    constructor(board) {\n        this._boardSize = CONSTANTS.boardSize;\n        this._numCells = this._boardSize * this._boardSize;\n        this._reset();\n        this._board = board;\n        this._boxInfo = CONSTANTS.boxInfo;\n    }\n\n\n    // Public methods\n\n    play() {\n        const puzzle = new Puzzle();\n        puzzle.solve();\n        const cellDB = puzzle.getCellDB();\n        this._setCellDB(cellDB);\n        this.populateBoard();\n        const boardSize = this._boardSize;\n        this._board.play(this);\n    }\n\n    getCellDB() {\n        return this.cellDB;\n    }\n\n    populateBoard() {\n        this._board.populate(this.cellDB);\n    }\n    \n    userHasSolvedPuzzle() {\n        const boardSize = this._boardSize;\n\n        // Returns if board isn't filled yet.\n        if (this.cellDB.getFilledCellCount() !== boardSize * boardSize) {\n            return false;\n        }\n\n        // Checks row and columns for conflicts and correct number counts\n        for (let i = 0; i < boardSize; i++) {\n            const rowValues = new Set(this.cellDB.getRowValues(i));\n            const columnValues = new Set(this.cellDB.getColumnValues(i));\n\n            if (rowValues.size !== boardSize || columnValues.size !== boardSize) {\n                return false;\n            }\n        }\n\n        // Checks for box conflicts\n        for (let box in this._boxInfo) {\n            if (this._boxInfo.hasOwnProperty(box)) {\n                const boxValues = new Set(this.cellDB.getBoxValues(box));\n\n                if (boxValues.size !== boardSize) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    getConflictingCellIndex() {\n        return this._board.getConflictingCellIndex();\n    }\n\n    setConflictingCellIndex(index) {\n        this._board.setConflictingCellIndex(index);\n    }\n\n    playInCell(cellX, cellY, cellValue) {\n        this.cellDB.setCellValue(cellX, cellY, 0);\n        this.cellDB.setCellValue(cellX, cellY, cellValue);\n        this.cellDB.incrementCellValueCount(cellValue);\n    }\n\n    highlightIfConflicting(cellX, cellY, cellValue) {\n\n        // Searches for conflicts, breaking out of loop if it finds one, in which case highlighting is done. \n\n        let conflictFound = false;\n        const boardSize = this._boardSize;\n\n        // Searches row for conflict:\n        for (let x = 0; x < boardSize; x++) {\n\n            // don't compare with self\n            if (x === cellX) {\n                continue;\n            }\n\n            if (this.cellDB.getCellValue(x, cellY) === cellValue) {\n                conflictFound = true;\n                break;\n            }\n        }\n\n        if (conflictFound) {\n            this._setBoardConflict(cellX, cellY, true);\n            return;\n        }\n\n        // Searches column for conflict:\n        for (let y = 0; y < boardSize; y++) {\n\n            if (y === cellY) {\n                continue;\n            }\n\n            if (this.cellDB.getCellValue(cellX, y) === cellValue) {\n                conflictFound = true;\n                break;\n            }\n        }\n\n        if (conflictFound) {\n            this._setBoardConflict(cellX, cellY, true);\n            return;\n        }\n\n        // Searches box for conflict:\n        const corners = this._getBoxCorners(cellX, cellY);\n\n        for (let x = corners.startColumn; x <= corners.endColumn; x++) {\n\n            if (conflictFound) break;\n\n            for (let y = corners.startRow; y < corners.endRow; y++) {\n\n                if (x === cellX && y === cellY) {\n                    continue;\n                }\n\n                if (this.cellDB.getCellValue(x, y) === cellValue) {\n                    conflictFound = true;\n                    break;\n                }\n            }\n        }\n\n        if (conflictFound) {\n            this._setBoardConflict(cellX, cellY, true);\n            return;\n        }\n\n    }\n\n    removeAllConflicts() {\n        for (let cellY = 0; cellY < this._boardSize; cellY++) {\n            for (let cellX = 0; cellX < this._boardSize; cellX++) {\n                this._setBoardConflict(cellX, cellY, false);\n            }\n        }\n    }\n\n\n\n\n\n    // Private methods\n\n    _setBoardConflict(cellX, cellY, newStatus) {\n\n        const status = this.cellDB.getConflictStatus(cellX, cellY);\n\n        if (status === newStatus) {\n            return;\n        }\n\n        this.cellDB.setConflictStatus(cellX, cellY, newStatus);\n\n        if (newStatus === true) {\n            try {\n                this._addConflictHighlighting(cellX, cellY);\n            } catch (e) {\n                throw \"setConflictStatus caught exception: \" + e;\n            }\n        } else {\n            this._removeConflictHighlighting(cellX, cellY);\n        }\n    }\n\n    _setCellDB(cellDB) {\n        this.cellDB = cellDB;\n    }\n\n    _getBoxCorners(cellX, cellY) {\n        const startRow = Math.floor(cellY / 3) * 3;\n        const endRow = startRow + 2;\n        const startColumn = Math.floor(cellX / 3) * 3;\n        const endColumn = startColumn + 2;\n\n        const corners = {\n            startRow: startRow,\n            endRow: endRow,\n            startColumn: startColumn,\n            endColumn: endColumn\n        }\n\n        return corners;\n    }\n\n    _removeConflictHighlighting(cellX, cellY) {\n\n        if (this.cellDB.getCellClueStatus(cellX, cellY) === true) {\n            return;\n        }\n\n        this._board.removeConflictHighlighting(cellX, cellY);\n\n    }\n\n    _reset() {\n        this.cellDB = new CellDB();\n    }\n\n    _addConflictHighlighting(cellX, cellY) {\n\n        if (this.cellDB.getCellClueStatus(cellX, cellY) === true) {\n            return;\n        }\n\n        this._board.addConflictHighlighting(cellX, cellY);\n\n    }\n}\n\nmodule.exports = Game;\n\n\n//# sourceURL=webpack:///./src/js/game.js?");

/***/ }),

/***/ "./src/js/move.js":
/*!************************!*\
  !*** ./src/js/move.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Utilities = __webpack_require__(/*! ./utilities */ \"./src/js/utilities.js\");\n\n/**\n * @classdesc A Move holds the information related to a single filling in of a cell, including the cell value and the previous move (which is used for backtracking).\n */\nclass Move {\n    constructor(cellX, cellY, cellValue, previousMove) {\n        this._previousMove = null;\n        this._isDeadEnd = false;\n        this._deadEndNextMoves = [];\n\n        if (arguments.length < 3) {\n            this.cellX = this._getRandomInt(0, boardSize - 1);\n            this.cellY = this._getRandomInt(0, boardSize - 1);\n            this.cellValue = this._getRandomInt(1, boardSize);\n        } else if (arguments.length >= 3) {\n            this.cellX = cellX;\n            this.cellY = cellY;\n            this.cellValue = cellValue;\n        }\n        if (arguments.length === 4) {\n            this._previousMove = previousMove;\n        }\n    }\n\n\n    // Public methods\n\n\n    setPreviousMove(move) {\n        this._previousMove = move;\n    }\n\n    getPreviousMove() {\n        return this._previousMove;\n    }\n\n    getDeadEndNextMoves() {\n        return this._deadEndNextMoves;\n    }\n\n    addDeadEndNextMove(move) {\n        this._deadEndNextMoves.push(move);\n    }\n\n    getCellValue() {\n        return this.cellValue;\n    }\n\n    getCellX() {\n        return this.cellX;\n    }\n\n    getCellY() {\n        return this.cellY;\n    }\n\n    // Private methods\n\n    \n    _getRandomInt(min, max) {\n        return Utilities.getRandomInt(min, max);\n    }\n}\n\nmodule.exports = Move;\n\n//# sourceURL=webpack:///./src/js/move.js?");

/***/ }),

/***/ "./src/js/puzzle.js":
/*!**************************!*\
  !*** ./src/js/puzzle.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CellDB = __webpack_require__(/*! ./cellDB */ \"./src/js/cellDB.js\");\nconst Move = __webpack_require__(/*! ./move */ \"./src/js/move.js\");\nconst Solver = __webpack_require__(/*! ./solver */ \"./src/js/solver.js\");\nconst Utilities = __webpack_require__(/*! ./utilities */ \"./src/js/utilities.js\");\nconst CONSTANTS = __webpack_require__(/*! ./constants */ \"./src/js/constants.js\");\n\nconst log = console.log;\n\n/**\n * @classdesc Puzzle generates a solvable puzzle in the form of a CellDB object. It first generates a completed puzzle, then clears cells until it has the targetted number of clues.\n */\nclass Puzzle {\n    constructor(solver = new Solver()) {\n        this._solver = solver;\n        this._boardSize = CONSTANTS.boardSize;\n        this._cellDB = new CellDB();\n        this._solver.setCellDB(this._cellDB);\n        this._boxInfo = CONSTANTS.boxInfo;\n    }\n\n\n    // Public methods\n\n\n    getCellDB() {\n        return this._cellDB;\n    }\n\n    puzzleIsComplete() {\n        return this._solver.puzzleIsComplete();\n    }\n\n    tryMove(move) {\n        return this._solver.tryMove(move);\n    }\n\n    solve() {\n        this._solver.solve();\n        this._removeCluesFromSolvedBoard();\n    }\n\n\n    // Private methods\n\n\n    _removeClue(cellX, cellY) {\n        if (this._cellDB.getCellValue(cellX, cellY) === 0) {\n            return false;\n        }\n\n        this._cellDB.setCellValue(cellX, cellY, 0);\n        this._cellDB.setCellClueStatus(cellX, cellY, false);\n\n        return true;\n    }\n\n    _randomInt(min, max) {\n        return Utilities.getRandomInt(min, max);\n    }\n\n    _removeCluesFromSolvedBoard(difficulty) {\n        let removalFunc;\n\n        if (difficulty === 'dev') {\n            removalFunc = this._removeOneClueFromSolvedBoard;\n        } else {\n            removalFunc = this._removeCluesFromSolvedBoardMediumDifficulty;\n        }\n\n        removalFunc.call(this);\n    }\n\n    _removeOneClueFromSolvedBoard() {\n        // For development purposes\n        this._removeClue(0, 0);\n    }\n\n    _removeCluesFromSolvedBoardMediumDifficulty() {\n        /* \n        \n        We need to remove some values from the solved board so it can be played. Removing values must leave the board with rotational symmetry.\n        \n        To achieve this symmetry, do valid removals until we get to our target number of clues. \n        \n        A valid removal means: \n        1) remove the value of the centre cell, and/or\n        2) remove values from any pair of cells where the cells aren't on same side and there is a cell in between them\n        \n        The valid removals are then: centre, ne-sw, nw-se, e-w, and n-s, plus all combinations of these.\n        \n        To be able to select any combination of these, randomly select DO or SKIP for each one.\n        \n        In case all are skipped, and in order to avoid having a fully populated box, pick one of the valid removals at random and do it.\n        \n        An easy board at websudoku.com seems to have 33-36 filled cells ('clues'), depending on the number of filled cells in the center box (nCenter). \n        \n        If nCenter is even: nClues = 34 or 36, X = nClues - nCenter. A set of four adjacent boxes is chosen and shares X/2 clues. Remove a value at random from each. Then, until the total number of clues in these boxes is X/2, randomly choose one of the boxes and randomly remove a value. Do the same to the rotationally symmetric cells in the other four boxes. \n        \n        If nCenter is odd: nClues = 33 or 35, X = nClues - (nCenter + 1). Repeat as above.\n\n        Skip the removal if it would leave a row, column or box empty.\n        */\n\n        let clueCount = this._boardSize * this._boardSize; // 81\n        const numCluesRemovedFromCenterBox = this._removeValuesFromCenterBox();\n        const centerBoxClueCount = this._boardSize - numCluesRemovedFromCenterBox; // eg. 2 or 3\n        clueCount -= numCluesRemovedFromCenterBox; // e.g. 79 or 78\n        const clueCountTarget = (clueCount % 2 == 0) ? 35 : 34;\n        const clueCountTargetForOneSide = Math.floor((clueCountTarget - centerBoxClueCount) / 2);\n        const boxesOfOneSide = ['nw', 'w', 'sw', 's'];\n        let removalCountByBox = { 'nw': 0, 'w': 0, 'sw': 0, 's': 0 };\n\n        const board = this;\n\n        // Removes a value from each box and its counterpart\n        boxesOfOneSide.forEach(function (box) {\n            board._removeRandomClueFromBoxAndItsCounterpart(box);\n            removalCountByBox[box]++;\n        });\n\n        clueCount -= 2 * boxesOfOneSide.length;\n\n        while (clueCount > clueCountTarget) {\n            const box = boxesOfOneSide[Math.floor(Math.random() * boxesOfOneSide.length)];\n\n            // Removes unless 8 have already been removed from box\n            if (removalCountByBox[box] < this._boardSize - 1) {\n\n                this._removeRandomClueFromBoxAndItsCounterpart(box);\n                removalCountByBox[box]++;\n                clueCount -= 2;\n            }\n        }\n\n\n    }\n\n    _rotate(coordinate) {\n        let result = -1;\n\n        switch (coordinate) {\n            case 0:\n                result = 2;\n                break;\n            case 1:\n                result = 1;\n                break;\n            case 2:\n                result = 0;\n                break;\n        }\n\n        return result;\n    }\n\n    _removeRandomClueFromBoxAndItsCounterpart(box) {\n        const board = this;\n\n        let triedCells = new Set();\n        let firstValueWasRemoved = false;\n\n        // Loops until we actually remove values\n        while (!firstValueWasRemoved && triedCells.size < this._boardSize) {\n\n            // Tries to remove the value of a cell in box:\n\n            const boxInfo = this._boxInfo[box];\n            const startCellX = boxInfo.startCellX;\n            const endCellX = boxInfo.endCellX;\n            const startCellY = boxInfo.startCellY;\n            const endCellY = boxInfo.endCellY;\n            const counterpartBox = boxInfo.counterpart;\n\n            const cellX = this._randomInt(startCellX, endCellX);\n            const cellY = this._randomInt(startCellY, endCellY);\n\n            // Keeps track of cells seen so far, so we don't loop forever.\n\n            triedCells.add(cellX.toString() + cellY.toString());\n\n            firstValueWasRemoved = board._removeClue(cellX, cellY);\n\n            // Tries to remove the value of the corresponding cell in the counterpart box:\n\n            const boxInfo2 = this._boxInfo[counterpartBox];\n            const startCellX2 = boxInfo2.startCellX;\n            const endCellX2 = boxInfo2.endCellX;\n            const startCellY2 = boxInfo2.startCellY;\n            const endCellY2 = boxInfo2.endCellY;\n\n            const cellX2 = this._rotate(cellX % 3) + startCellX2;\n            const cellY2 = this._rotate(cellY % 3) + startCellY2;\n\n            board._removeClue(cellX2, cellY2);\n        }\n\n        return firstValueWasRemoved;\n    }\n\n    _removeValuesFromCenterBox() {\n        // 33 43 53   nw n ne \n        // 34 44 54 = w  c  e\n        // 35 45 55   sw s se\n\n        let removals = {\n            'nw-se': [{ cellX: 3, cellY: 3 }, { cellX: 5, cellY: 5 }],\n            'sw-ne': [{ cellX: 3, cellY: 5 }, { cellX: 5, cellY: 3 }],\n            'e-w': [{ cellX: 3, cellY: 4 }, { cellX: 5, cellY: 4 }],\n            'n-s': [{ cellX: 4, cellY: 3 }, { cellX: 4, cellY: 5 }],\n            'c': [{ cellX: 4, cellY: 4 }]\n        };\n\n        const removalKeys = Object.keys(removals);\n\n        let booleans = [];\n        let allRemoved = true;\n        let noneRemoved = true;\n\n        for (let i = 0; i < removalKeys.length; i++) {\n            const bool = Math.random() >= 0.5;\n            booleans[i] = bool;\n\n            if (bool) {\n                noneRemoved = false;\n            } else {\n                allRemoved = false;\n            }\n        }\n\n        if (noneRemoved || allRemoved) {\n            const randIndex = this._randomInt(0, removalKeys.length - 1);\n            booleans[randIndex] = !booleans[randIndex];\n        }\n\n\n        const board = this;\n        let removedValueCount = 0;\n\n        for (let k = 0; k < removalKeys.length; k++) {\n            const bool = booleans[k];\n            const key = removalKeys[k];\n\n            if (bool) {\n                removals[key].forEach(function (cell, index) {\n                    board._removeClue(cell.cellX, cell.cellY);\n                    ++removedValueCount;\n                });\n            }\n        }\n\n        return removedValueCount;\n    }\n\n}\n\nmodule.exports = Puzzle;\n\n//# sourceURL=webpack:///./src/js/puzzle.js?");

/***/ }),

/***/ "./src/js/solver.js":
/*!**************************!*\
  !*** ./src/js/solver.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Move = __webpack_require__(/*! ./move */ \"./src/js/move.js\");\nconst CONSTANTS = __webpack_require__(/*! ./constants */ \"./src/js/constants.js\");\nconst log = console.log;\n\n/**\n * @classdesc Solver creates a completed puzzle.\n */\nclass Solver {\n    constructor() {\n        this._moves = [];\n        this._boardSize = CONSTANTS.boardSize;\n        this._moveAttempts = 0;\n        this._validMoveCount = 0;\n\n        Array.prototype.diff = function (arr) {\n            // From https://stackoverflow.com/a/4026828\n            return this.filter(function (i) {\n                return arr.indexOf(i) < 0;\n            });\n        };\n    }\n\n    \n    // Public methods\n\n\n    setCellDB(cellDB) {\n        this._cellDB = cellDB;\n    }\n\n    solve() {\n        this._solveByPickingRandomPossibleNextMove();\n    }\n\n    moveIsValid(move) {\n        return this.rowIsValid(move) && this.columnIsValid(move) && this.boxIsValid(move);\n    }\n\n    rowIsValid(move) {\n        return this._cellDB.rowIsValid(move);\n    }\n\n    boxIsValid(move) {\n        return this._cellDB.boxIsValid(move);\n    }\n\n    columnIsValid(move) {\n        return this._cellDB.columnIsValid(move);\n    }\n\n    puzzleIsComplete() {\n        return this._cellDB.getCompleteCellValueCount() === this._boardSize;\n    }\n\n    tryMove(move) {\n        this._moveAttempts++;\n        if (this._cellDB.cellIsEmpty(move.getCellX(), move.getCellY()) && this.moveIsValid(move)) {\n            this._cellDB.setCellValue(move.getCellX(), move.getCellY(), move.getCellValue());\n            this._validMoveCount++;\n            this._moves.push(move);\n            this._cellDB.incrementCellValueCount(move.getCellValue());\n            // log(this.cellDB);\n            return true;\n        } else {\n            // log(this.cellDB);\n            return false;\n        }\n    }\n\n    // Private methods\n\n    _solveByPickingRandomPossibleNextMove() {\n\n        let lastMove = this._getLastMove();\n        let cellValue = null;\n\n        // check whether this is the first move we're trying to make\n        if (lastMove) {\n            cellValue = lastMove.getCellValue();\n        } else {\n            // as we look for somewhere to move, we start with cell value '1', i.e.\n            // placing as many 1s on the board as we can, and working our way up to 9\n            cellValue = 1;\n        }\n\n        while (this._cellDB.getCellValueCount(cellValue) < this._boardSize && (!this.puzzleIsComplete())) {\n            lastMove = this._getLastMove();\n\n            if (!lastMove) {\n                // no moves yet\n                lastMove = new Move(-1, -1, cellValue);\n            }\n\n            let possibleNextMoves = this._getPossibleNextMoves(lastMove);\n            let moveMade = false;\n\n            // loop until we've successfully moved\n            while (!moveMade) {\n\n                // backtrack if there's nowhere to move, then look again for candidate moves\n                if (possibleNextMoves.length === 0) {\n                    this._undoLastMove();\n                    lastMove = this._getLastMove();\n                    possibleNextMoves = this._getPossibleNextMoves(lastMove);\n                }\n\n                // if backtracking helped us find candidate moves, pick one at random\n                const moveCandidate = this._pickRandomElementFromArray(possibleNextMoves);\n                moveMade = this.tryMove(moveCandidate);\n\n                // we use a linked list to keep track of move order (so as to facilitate backtracking),\n                // so if we ever make a move, link it to its predecessor\n                if (moveMade) {\n                    moveCandidate.setPreviousMove(lastMove);\n                    if (cellValue < this._boardSize) {\n                        cellValue++;\n                    }\n                } else {\n                    // tick off the unsuccessful candidate so we don't pick it again\n                    possibleNextMoves.splice(possibleNextMoves.indexOf(moveCandidate), 1);\n                }\n            }\n        }\n    }\n\n    _getLastMove() {\n        if (this._moves.length === 0) {\n            return null;\n        }\n        return this._moves[this._moves.length - 1];\n    }\n\n    _getPossibleNextMoves(move) {\n        let possibleCellYs = [];\n\n        for (let i = 0; i < this._boardSize; i++) {\n            if (i != move.getCellY()) {\n                possibleCellYs.push(i);\n            }\n        }\n\n        let cellValue = move.getCellValue();\n        let cellValueCount = this._cellDB.getCellValueCount(cellValue);\n\n        // start working on the next value when we have 9 of the current one\n        if (cellValueCount === this._boardSize) {\n            ++cellValue;\n\n            if (this._cellDB.getCellValueCount(cellValue) === this._boardSize) {\n                throw \"Unexpected cell value count. Terminating.\";\n            }\n        }\n\n        const deadEndCellYs = move.getDeadEndNextMoves().map(mv => mv.cellY);\n        let cellX = (move.getCellX() + 1) % this._boardSize;\n        const possibleNextMoves = possibleCellYs.diff(deadEndCellYs).map(cellY => new Move(cellX, cellY, cellValue));\n\n        return possibleNextMoves;\n    }\n\n    _undoLastMove() {\n        if (this._moves.length > 0) {\n            const lastMove = this._moves.pop();\n            lastMove.deadEnd = true;\n            this._cellDB.setCellValue(lastMove.getCellX(), lastMove.getCellY(), 0);\n            this._cellDB.decrementCellValueCount(lastMove.getCellValue());\n            lastMove.getPreviousMove().addDeadEndNextMove(lastMove);\n            return lastMove;\n        } else {\n            return;\n        }\n    }\n\n    _pickRandomElementFromArray(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n}\n\nmodule.exports = Solver;\n\n//# sourceURL=webpack:///./src/js/solver.js?");

/***/ }),

/***/ "./src/js/utilities.js":
/*!*****************************!*\
  !*** ./src/js/utilities.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const utilities = {\n  getRandomInt: function (min, max) { // inclusive - https://stackoverflow.com/a/1527820\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n}\n\nmodule.exports = utilities;\n\n//# sourceURL=webpack:///./src/js/utilities.js?");

/***/ })

/******/ });